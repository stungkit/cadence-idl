// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: uber/cadence/api/v1/schedule.proto

package apiv1

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ScheduleOverlapPolicy defines behavior when a new run is scheduled while a previous run is still active.
type ScheduleOverlapPolicy int32

const (
	ScheduleOverlapPolicy_SCHEDULE_OVERLAP_POLICY_INVALID ScheduleOverlapPolicy = 0
	// Skip the new run if the previous is still running.
	ScheduleOverlapPolicy_SCHEDULE_OVERLAP_POLICY_SKIP_NEW ScheduleOverlapPolicy = 1
	// Buffer new runs and execute them sequentially.
	// Controlled by buffer_limit in SchedulePolicies (0 = unlimited, N = max N queued).
	ScheduleOverlapPolicy_SCHEDULE_OVERLAP_POLICY_BUFFER ScheduleOverlapPolicy = 2
	// Allow runs to execute concurrently.
	// Controlled by concurrency_limit in SchedulePolicies (0 = unlimited, N = max N concurrent).
	ScheduleOverlapPolicy_SCHEDULE_OVERLAP_POLICY_CONCURRENT ScheduleOverlapPolicy = 3
	// Cancel the previous run gracefully and start the new one.
	ScheduleOverlapPolicy_SCHEDULE_OVERLAP_POLICY_CANCEL_PREVIOUS ScheduleOverlapPolicy = 4
	// Terminate the previous run immediately and start the new one.
	ScheduleOverlapPolicy_SCHEDULE_OVERLAP_POLICY_TERMINATE_PREVIOUS ScheduleOverlapPolicy = 5
)

var ScheduleOverlapPolicy_name = map[int32]string{
	0: "SCHEDULE_OVERLAP_POLICY_INVALID",
	1: "SCHEDULE_OVERLAP_POLICY_SKIP_NEW",
	2: "SCHEDULE_OVERLAP_POLICY_BUFFER",
	3: "SCHEDULE_OVERLAP_POLICY_CONCURRENT",
	4: "SCHEDULE_OVERLAP_POLICY_CANCEL_PREVIOUS",
	5: "SCHEDULE_OVERLAP_POLICY_TERMINATE_PREVIOUS",
}

var ScheduleOverlapPolicy_value = map[string]int32{
	"SCHEDULE_OVERLAP_POLICY_INVALID":            0,
	"SCHEDULE_OVERLAP_POLICY_SKIP_NEW":           1,
	"SCHEDULE_OVERLAP_POLICY_BUFFER":             2,
	"SCHEDULE_OVERLAP_POLICY_CONCURRENT":         3,
	"SCHEDULE_OVERLAP_POLICY_CANCEL_PREVIOUS":    4,
	"SCHEDULE_OVERLAP_POLICY_TERMINATE_PREVIOUS": 5,
}

func (x ScheduleOverlapPolicy) String() string {
	return proto.EnumName(ScheduleOverlapPolicy_name, int32(x))
}

func (ScheduleOverlapPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7fe71309dc9555dc, []int{0}
}

// ScheduleCatchUpPolicy defines how missed runs are handled on unpause or system recovery.
// Catch-up runs are subject to the configured overlap policy: if the overlap buffer is full,
// excess catch-up runs are dropped.
type ScheduleCatchUpPolicy int32

const (
	ScheduleCatchUpPolicy_SCHEDULE_CATCH_UP_POLICY_INVALID ScheduleCatchUpPolicy = 0
	// Skip all missed runs.
	ScheduleCatchUpPolicy_SCHEDULE_CATCH_UP_POLICY_SKIP ScheduleCatchUpPolicy = 1
	// Only run the most recent missed scheduled time, skip all others.
	ScheduleCatchUpPolicy_SCHEDULE_CATCH_UP_POLICY_ONE ScheduleCatchUpPolicy = 2
	// Run for each missed run, up to the catch_up_window.
	ScheduleCatchUpPolicy_SCHEDULE_CATCH_UP_POLICY_ALL ScheduleCatchUpPolicy = 3
)

var ScheduleCatchUpPolicy_name = map[int32]string{
	0: "SCHEDULE_CATCH_UP_POLICY_INVALID",
	1: "SCHEDULE_CATCH_UP_POLICY_SKIP",
	2: "SCHEDULE_CATCH_UP_POLICY_ONE",
	3: "SCHEDULE_CATCH_UP_POLICY_ALL",
}

var ScheduleCatchUpPolicy_value = map[string]int32{
	"SCHEDULE_CATCH_UP_POLICY_INVALID": 0,
	"SCHEDULE_CATCH_UP_POLICY_SKIP":    1,
	"SCHEDULE_CATCH_UP_POLICY_ONE":     2,
	"SCHEDULE_CATCH_UP_POLICY_ALL":     3,
}

func (x ScheduleCatchUpPolicy) String() string {
	return proto.EnumName(ScheduleCatchUpPolicy_name, int32(x))
}

func (ScheduleCatchUpPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7fe71309dc9555dc, []int{1}
}

// ScheduleSpec defines when a schedule should trigger.
type ScheduleSpec struct {
	// Standard cron expression (e.g., "0 6 * * *").
	// Timezone can be embedded using CRON_TZ prefix (e.g., "CRON_TZ=America/Los_Angeles 0 6 * * *").
	// Defaults to UTC if no timezone specified.
	CronExpression string `protobuf:"bytes,1,opt,name=cron_expression,json=cronExpression,proto3" json:"cron_expression,omitempty"`
	// Earliest time the schedule should trigger. If not set, starts immediately.
	StartTime *types.Timestamp `protobuf:"bytes,2,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// Latest time the schedule should trigger. If not set, runs indefinitely.
	EndTime *types.Timestamp `protobuf:"bytes,3,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// Random jitter applied to each trigger time to spread load.
	// The actual trigger time will be offset by a random duration in [0, jitter).
	Jitter               *types.Duration `protobuf:"bytes,4,opt,name=jitter,proto3" json:"jitter,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ScheduleSpec) Reset()         { *m = ScheduleSpec{} }
func (m *ScheduleSpec) String() string { return proto.CompactTextString(m) }
func (*ScheduleSpec) ProtoMessage()    {}
func (*ScheduleSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fe71309dc9555dc, []int{0}
}
func (m *ScheduleSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduleSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScheduleSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScheduleSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduleSpec.Merge(m, src)
}
func (m *ScheduleSpec) XXX_Size() int {
	return m.Size()
}
func (m *ScheduleSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduleSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduleSpec proto.InternalMessageInfo

func (m *ScheduleSpec) GetCronExpression() string {
	if m != nil {
		return m.CronExpression
	}
	return ""
}

func (m *ScheduleSpec) GetStartTime() *types.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *ScheduleSpec) GetEndTime() *types.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *ScheduleSpec) GetJitter() *types.Duration {
	if m != nil {
		return m.Jitter
	}
	return nil
}

// ScheduleAction defines what action to take when the schedule triggers.
// Exactly one action field must be set.
type ScheduleAction struct {
	// Start a new workflow execution on each trigger.
	StartWorkflow        *ScheduleAction_StartWorkflowAction `protobuf:"bytes,1,opt,name=start_workflow,json=startWorkflow,proto3" json:"start_workflow,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                            `json:"-"`
	XXX_unrecognized     []byte                              `json:"-"`
	XXX_sizecache        int32                               `json:"-"`
}

func (m *ScheduleAction) Reset()         { *m = ScheduleAction{} }
func (m *ScheduleAction) String() string { return proto.CompactTextString(m) }
func (*ScheduleAction) ProtoMessage()    {}
func (*ScheduleAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fe71309dc9555dc, []int{1}
}
func (m *ScheduleAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduleAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScheduleAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScheduleAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduleAction.Merge(m, src)
}
func (m *ScheduleAction) XXX_Size() int {
	return m.Size()
}
func (m *ScheduleAction) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduleAction.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduleAction proto.InternalMessageInfo

func (m *ScheduleAction) GetStartWorkflow() *ScheduleAction_StartWorkflowAction {
	if m != nil {
		return m.StartWorkflow
	}
	return nil
}

// StartWorkflowAction starts a new workflow execution on each trigger.
type ScheduleAction_StartWorkflowAction struct {
	// Workflow type to start.
	WorkflowType *WorkflowType `protobuf:"bytes,1,opt,name=workflow_type,json=workflowType,proto3" json:"workflow_type,omitempty"`
	// Task list for the target workflow.
	TaskList *TaskList `protobuf:"bytes,2,opt,name=task_list,json=taskList,proto3" json:"task_list,omitempty"`
	// Input payload for the target workflow.
	Input *Payload `protobuf:"bytes,3,opt,name=input,proto3" json:"input,omitempty"`
	// Prefix for generating the target workflow ID.
	WorkflowIdPrefix string `protobuf:"bytes,4,opt,name=workflow_id_prefix,json=workflowIdPrefix,proto3" json:"workflow_id_prefix,omitempty"`
	// Execution timeout for the target workflow.
	ExecutionStartToCloseTimeout *types.Duration `protobuf:"bytes,5,opt,name=execution_start_to_close_timeout,json=executionStartToCloseTimeout,proto3" json:"execution_start_to_close_timeout,omitempty"`
	// Decision task timeout for the target workflow.
	TaskStartToCloseTimeout *types.Duration `protobuf:"bytes,6,opt,name=task_start_to_close_timeout,json=taskStartToCloseTimeout,proto3" json:"task_start_to_close_timeout,omitempty"`
	// Retry policy for the target workflow.
	RetryPolicy *RetryPolicy `protobuf:"bytes,7,opt,name=retry_policy,json=retryPolicy,proto3" json:"retry_policy,omitempty"`
	// Additional memo data to attach to the target workflow.
	Memo *Memo `protobuf:"bytes,8,opt,name=memo,proto3" json:"memo,omitempty"`
	// Search attributes to attach to the target workflow.
	SearchAttributes     *SearchAttributes `protobuf:"bytes,9,opt,name=search_attributes,json=searchAttributes,proto3" json:"search_attributes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ScheduleAction_StartWorkflowAction) Reset()         { *m = ScheduleAction_StartWorkflowAction{} }
func (m *ScheduleAction_StartWorkflowAction) String() string { return proto.CompactTextString(m) }
func (*ScheduleAction_StartWorkflowAction) ProtoMessage()    {}
func (*ScheduleAction_StartWorkflowAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fe71309dc9555dc, []int{1, 0}
}
func (m *ScheduleAction_StartWorkflowAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduleAction_StartWorkflowAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScheduleAction_StartWorkflowAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScheduleAction_StartWorkflowAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduleAction_StartWorkflowAction.Merge(m, src)
}
func (m *ScheduleAction_StartWorkflowAction) XXX_Size() int {
	return m.Size()
}
func (m *ScheduleAction_StartWorkflowAction) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduleAction_StartWorkflowAction.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduleAction_StartWorkflowAction proto.InternalMessageInfo

func (m *ScheduleAction_StartWorkflowAction) GetWorkflowType() *WorkflowType {
	if m != nil {
		return m.WorkflowType
	}
	return nil
}

func (m *ScheduleAction_StartWorkflowAction) GetTaskList() *TaskList {
	if m != nil {
		return m.TaskList
	}
	return nil
}

func (m *ScheduleAction_StartWorkflowAction) GetInput() *Payload {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *ScheduleAction_StartWorkflowAction) GetWorkflowIdPrefix() string {
	if m != nil {
		return m.WorkflowIdPrefix
	}
	return ""
}

func (m *ScheduleAction_StartWorkflowAction) GetExecutionStartToCloseTimeout() *types.Duration {
	if m != nil {
		return m.ExecutionStartToCloseTimeout
	}
	return nil
}

func (m *ScheduleAction_StartWorkflowAction) GetTaskStartToCloseTimeout() *types.Duration {
	if m != nil {
		return m.TaskStartToCloseTimeout
	}
	return nil
}

func (m *ScheduleAction_StartWorkflowAction) GetRetryPolicy() *RetryPolicy {
	if m != nil {
		return m.RetryPolicy
	}
	return nil
}

func (m *ScheduleAction_StartWorkflowAction) GetMemo() *Memo {
	if m != nil {
		return m.Memo
	}
	return nil
}

func (m *ScheduleAction_StartWorkflowAction) GetSearchAttributes() *SearchAttributes {
	if m != nil {
		return m.SearchAttributes
	}
	return nil
}

// SchedulePolicies configures schedule behavior.
type SchedulePolicies struct {
	// Defines what happens when a new run is scheduled while the previous is still running.
	OverlapPolicy ScheduleOverlapPolicy `protobuf:"varint,1,opt,name=overlap_policy,json=overlapPolicy,proto3,enum=uber.cadence.api.v1.ScheduleOverlapPolicy" json:"overlap_policy,omitempty"`
	// Defines how missed runs are handled on unpause or system recovery.
	CatchUpPolicy ScheduleCatchUpPolicy `protobuf:"varint,2,opt,name=catch_up_policy,json=catchUpPolicy,proto3,enum=uber.cadence.api.v1.ScheduleCatchUpPolicy" json:"catch_up_policy,omitempty"`
	// Maximum time to look back for missed runs. Runs older than this window are skipped.
	// If not set, the server uses a default (configurable via dynamic config).
	CatchUpWindow *types.Duration `protobuf:"bytes,3,opt,name=catch_up_window,json=catchUpWindow,proto3" json:"catch_up_window,omitempty"`
	// If true, pause the schedule when a triggered workflow fails.
	PauseOnFailure bool `protobuf:"varint,4,opt,name=pause_on_failure,json=pauseOnFailure,proto3" json:"pause_on_failure,omitempty"`
	// Maximum number of runs to buffer when overlap_policy is BUFFER.
	// 0 means unlimited. Only used with SCHEDULE_OVERLAP_POLICY_BUFFER.
	BufferLimit int32 `protobuf:"varint,5,opt,name=buffer_limit,json=bufferLimit,proto3" json:"buffer_limit,omitempty"`
	// Maximum number of runs executing concurrently when overlap_policy is CONCURRENT.
	// 0 means unlimited. Only used with SCHEDULE_OVERLAP_POLICY_CONCURRENT.
	ConcurrencyLimit     int32    `protobuf:"varint,6,opt,name=concurrency_limit,json=concurrencyLimit,proto3" json:"concurrency_limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SchedulePolicies) Reset()         { *m = SchedulePolicies{} }
func (m *SchedulePolicies) String() string { return proto.CompactTextString(m) }
func (*SchedulePolicies) ProtoMessage()    {}
func (*SchedulePolicies) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fe71309dc9555dc, []int{2}
}
func (m *SchedulePolicies) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchedulePolicies) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchedulePolicies.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchedulePolicies) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedulePolicies.Merge(m, src)
}
func (m *SchedulePolicies) XXX_Size() int {
	return m.Size()
}
func (m *SchedulePolicies) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedulePolicies.DiscardUnknown(m)
}

var xxx_messageInfo_SchedulePolicies proto.InternalMessageInfo

func (m *SchedulePolicies) GetOverlapPolicy() ScheduleOverlapPolicy {
	if m != nil {
		return m.OverlapPolicy
	}
	return ScheduleOverlapPolicy_SCHEDULE_OVERLAP_POLICY_INVALID
}

func (m *SchedulePolicies) GetCatchUpPolicy() ScheduleCatchUpPolicy {
	if m != nil {
		return m.CatchUpPolicy
	}
	return ScheduleCatchUpPolicy_SCHEDULE_CATCH_UP_POLICY_INVALID
}

func (m *SchedulePolicies) GetCatchUpWindow() *types.Duration {
	if m != nil {
		return m.CatchUpWindow
	}
	return nil
}

func (m *SchedulePolicies) GetPauseOnFailure() bool {
	if m != nil {
		return m.PauseOnFailure
	}
	return false
}

func (m *SchedulePolicies) GetBufferLimit() int32 {
	if m != nil {
		return m.BufferLimit
	}
	return 0
}

func (m *SchedulePolicies) GetConcurrencyLimit() int32 {
	if m != nil {
		return m.ConcurrencyLimit
	}
	return 0
}

// SchedulePauseInfo captures the state of a paused schedule.
type SchedulePauseInfo struct {
	// User-provided reason for pausing.
	Reason string `protobuf:"bytes,1,opt,name=reason,proto3" json:"reason,omitempty"`
	// Time when the schedule was paused.
	PausedAt *types.Timestamp `protobuf:"bytes,2,opt,name=paused_at,json=pausedAt,proto3" json:"paused_at,omitempty"`
	// Identity of the actor that paused the schedule.
	PausedBy             string   `protobuf:"bytes,3,opt,name=paused_by,json=pausedBy,proto3" json:"paused_by,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SchedulePauseInfo) Reset()         { *m = SchedulePauseInfo{} }
func (m *SchedulePauseInfo) String() string { return proto.CompactTextString(m) }
func (*SchedulePauseInfo) ProtoMessage()    {}
func (*SchedulePauseInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fe71309dc9555dc, []int{3}
}
func (m *SchedulePauseInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchedulePauseInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchedulePauseInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchedulePauseInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedulePauseInfo.Merge(m, src)
}
func (m *SchedulePauseInfo) XXX_Size() int {
	return m.Size()
}
func (m *SchedulePauseInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedulePauseInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SchedulePauseInfo proto.InternalMessageInfo

func (m *SchedulePauseInfo) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *SchedulePauseInfo) GetPausedAt() *types.Timestamp {
	if m != nil {
		return m.PausedAt
	}
	return nil
}

func (m *SchedulePauseInfo) GetPausedBy() string {
	if m != nil {
		return m.PausedBy
	}
	return ""
}

// ScheduleState represents the current runtime state of a schedule.
type ScheduleState struct {
	// Whether the schedule is currently paused.
	Paused bool `protobuf:"varint,1,opt,name=paused,proto3" json:"paused,omitempty"`
	// Details about the pause, present only when paused is true.
	PauseInfo            *SchedulePauseInfo `protobuf:"bytes,2,opt,name=pause_info,json=pauseInfo,proto3" json:"pause_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ScheduleState) Reset()         { *m = ScheduleState{} }
func (m *ScheduleState) String() string { return proto.CompactTextString(m) }
func (*ScheduleState) ProtoMessage()    {}
func (*ScheduleState) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fe71309dc9555dc, []int{4}
}
func (m *ScheduleState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduleState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScheduleState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScheduleState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduleState.Merge(m, src)
}
func (m *ScheduleState) XXX_Size() int {
	return m.Size()
}
func (m *ScheduleState) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduleState.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduleState proto.InternalMessageInfo

func (m *ScheduleState) GetPaused() bool {
	if m != nil {
		return m.Paused
	}
	return false
}

func (m *ScheduleState) GetPauseInfo() *SchedulePauseInfo {
	if m != nil {
		return m.PauseInfo
	}
	return nil
}

// BackfillInfo tracks the progress of an ongoing backfill operation.
type BackfillInfo struct {
	// Backfill identifier, as provided in BackfillScheduleRequest.
	BackfillId string `protobuf:"bytes,1,opt,name=backfill_id,json=backfillId,proto3" json:"backfill_id,omitempty"`
	// Start of the backfill time range.
	StartTime *types.Timestamp `protobuf:"bytes,2,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// End of the backfill time range.
	EndTime *types.Timestamp `protobuf:"bytes,3,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// Number of runs completed so far.
	RunsCompleted int32 `protobuf:"varint,4,opt,name=runs_completed,json=runsCompleted,proto3" json:"runs_completed,omitempty"`
	// Total number of runs in this backfill range.
	RunsTotal            int32    `protobuf:"varint,5,opt,name=runs_total,json=runsTotal,proto3" json:"runs_total,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BackfillInfo) Reset()         { *m = BackfillInfo{} }
func (m *BackfillInfo) String() string { return proto.CompactTextString(m) }
func (*BackfillInfo) ProtoMessage()    {}
func (*BackfillInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fe71309dc9555dc, []int{5}
}
func (m *BackfillInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BackfillInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BackfillInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BackfillInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BackfillInfo.Merge(m, src)
}
func (m *BackfillInfo) XXX_Size() int {
	return m.Size()
}
func (m *BackfillInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BackfillInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BackfillInfo proto.InternalMessageInfo

func (m *BackfillInfo) GetBackfillId() string {
	if m != nil {
		return m.BackfillId
	}
	return ""
}

func (m *BackfillInfo) GetStartTime() *types.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *BackfillInfo) GetEndTime() *types.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *BackfillInfo) GetRunsCompleted() int32 {
	if m != nil {
		return m.RunsCompleted
	}
	return 0
}

func (m *BackfillInfo) GetRunsTotal() int32 {
	if m != nil {
		return m.RunsTotal
	}
	return 0
}

// ScheduleInfo provides runtime information about the schedule.
type ScheduleInfo struct {
	// When the last run was triggered.
	LastRunTime *types.Timestamp `protobuf:"bytes,1,opt,name=last_run_time,json=lastRunTime,proto3" json:"last_run_time,omitempty"`
	// When the next run will be triggered.
	NextRunTime *types.Timestamp `protobuf:"bytes,2,opt,name=next_run_time,json=nextRunTime,proto3" json:"next_run_time,omitempty"`
	// Total number of workflows started by this schedule (includes regular, catch-up, and backfill runs).
	TotalRuns int64 `protobuf:"varint,3,opt,name=total_runs,json=totalRuns,proto3" json:"total_runs,omitempty"`
	// When the schedule was created.
	CreateTime *types.Timestamp `protobuf:"bytes,4,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	// When the schedule was last updated.
	LastUpdateTime *types.Timestamp `protobuf:"bytes,5,opt,name=last_update_time,json=lastUpdateTime,proto3" json:"last_update_time,omitempty"`
	// Currently active backfill operations. Removed when complete.
	OngoingBackfills     []*BackfillInfo `protobuf:"bytes,6,rep,name=ongoing_backfills,json=ongoingBackfills,proto3" json:"ongoing_backfills,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ScheduleInfo) Reset()         { *m = ScheduleInfo{} }
func (m *ScheduleInfo) String() string { return proto.CompactTextString(m) }
func (*ScheduleInfo) ProtoMessage()    {}
func (*ScheduleInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fe71309dc9555dc, []int{6}
}
func (m *ScheduleInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduleInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScheduleInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScheduleInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduleInfo.Merge(m, src)
}
func (m *ScheduleInfo) XXX_Size() int {
	return m.Size()
}
func (m *ScheduleInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduleInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduleInfo proto.InternalMessageInfo

func (m *ScheduleInfo) GetLastRunTime() *types.Timestamp {
	if m != nil {
		return m.LastRunTime
	}
	return nil
}

func (m *ScheduleInfo) GetNextRunTime() *types.Timestamp {
	if m != nil {
		return m.NextRunTime
	}
	return nil
}

func (m *ScheduleInfo) GetTotalRuns() int64 {
	if m != nil {
		return m.TotalRuns
	}
	return 0
}

func (m *ScheduleInfo) GetCreateTime() *types.Timestamp {
	if m != nil {
		return m.CreateTime
	}
	return nil
}

func (m *ScheduleInfo) GetLastUpdateTime() *types.Timestamp {
	if m != nil {
		return m.LastUpdateTime
	}
	return nil
}

func (m *ScheduleInfo) GetOngoingBackfills() []*BackfillInfo {
	if m != nil {
		return m.OngoingBackfills
	}
	return nil
}

// ScheduleListEntry represents a single schedule in a list response.
// Contains only data available from the visibility store.
type ScheduleListEntry struct {
	ScheduleId string `protobuf:"bytes,1,opt,name=schedule_id,json=scheduleId,proto3" json:"schedule_id,omitempty"`
	// Workflow type configured in the schedule action.
	WorkflowType *WorkflowType `protobuf:"bytes,2,opt,name=workflow_type,json=workflowType,proto3" json:"workflow_type,omitempty"`
	// Current state of the schedule.
	State *ScheduleState `protobuf:"bytes,3,opt,name=state,proto3" json:"state,omitempty"`
	// Cron expression for the schedule.
	CronExpression       string   `protobuf:"bytes,4,opt,name=cron_expression,json=cronExpression,proto3" json:"cron_expression,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ScheduleListEntry) Reset()         { *m = ScheduleListEntry{} }
func (m *ScheduleListEntry) String() string { return proto.CompactTextString(m) }
func (*ScheduleListEntry) ProtoMessage()    {}
func (*ScheduleListEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_7fe71309dc9555dc, []int{7}
}
func (m *ScheduleListEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduleListEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScheduleListEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScheduleListEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduleListEntry.Merge(m, src)
}
func (m *ScheduleListEntry) XXX_Size() int {
	return m.Size()
}
func (m *ScheduleListEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduleListEntry.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduleListEntry proto.InternalMessageInfo

func (m *ScheduleListEntry) GetScheduleId() string {
	if m != nil {
		return m.ScheduleId
	}
	return ""
}

func (m *ScheduleListEntry) GetWorkflowType() *WorkflowType {
	if m != nil {
		return m.WorkflowType
	}
	return nil
}

func (m *ScheduleListEntry) GetState() *ScheduleState {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *ScheduleListEntry) GetCronExpression() string {
	if m != nil {
		return m.CronExpression
	}
	return ""
}

func init() {
	proto.RegisterEnum("uber.cadence.api.v1.ScheduleOverlapPolicy", ScheduleOverlapPolicy_name, ScheduleOverlapPolicy_value)
	proto.RegisterEnum("uber.cadence.api.v1.ScheduleCatchUpPolicy", ScheduleCatchUpPolicy_name, ScheduleCatchUpPolicy_value)
	proto.RegisterType((*ScheduleSpec)(nil), "uber.cadence.api.v1.ScheduleSpec")
	proto.RegisterType((*ScheduleAction)(nil), "uber.cadence.api.v1.ScheduleAction")
	proto.RegisterType((*ScheduleAction_StartWorkflowAction)(nil), "uber.cadence.api.v1.ScheduleAction.StartWorkflowAction")
	proto.RegisterType((*SchedulePolicies)(nil), "uber.cadence.api.v1.SchedulePolicies")
	proto.RegisterType((*SchedulePauseInfo)(nil), "uber.cadence.api.v1.SchedulePauseInfo")
	proto.RegisterType((*ScheduleState)(nil), "uber.cadence.api.v1.ScheduleState")
	proto.RegisterType((*BackfillInfo)(nil), "uber.cadence.api.v1.BackfillInfo")
	proto.RegisterType((*ScheduleInfo)(nil), "uber.cadence.api.v1.ScheduleInfo")
	proto.RegisterType((*ScheduleListEntry)(nil), "uber.cadence.api.v1.ScheduleListEntry")
}

func init() {
	proto.RegisterFile("uber/cadence/api/v1/schedule.proto", fileDescriptor_7fe71309dc9555dc)
}

var fileDescriptor_7fe71309dc9555dc = []byte{
	// 1243 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0xcf, 0x6f, 0xdb, 0x36,
	0x14, 0x9e, 0x9c, 0x38, 0x8d, 0x9f, 0x63, 0x57, 0x61, 0xb1, 0xd5, 0x4b, 0x9b, 0xd4, 0xf5, 0xd6,
	0x1f, 0x48, 0x57, 0x1b, 0xc9, 0x30, 0x74, 0x5b, 0x81, 0x02, 0x8e, 0xa3, 0xa0, 0xc6, 0x5c, 0xdb,
	0x63, 0xec, 0x06, 0xdb, 0x61, 0x82, 0x2c, 0xd1, 0x09, 0x17, 0x59, 0x14, 0x24, 0x2a, 0x89, 0x6f,
	0xdb, 0x79, 0xff, 0xc6, 0xfe, 0x98, 0x1d, 0xf7, 0x07, 0x0c, 0xd8, 0xd0, 0xcb, 0xee, 0x3b, 0xec,
	0xba, 0x81, 0x14, 0xa5, 0xb8, 0xad, 0x1c, 0x17, 0xbb, 0xec, 0x26, 0x7e, 0xfc, 0xbe, 0x8f, 0xef,
	0x3d, 0x3e, 0x91, 0x84, 0x5a, 0x34, 0x22, 0x41, 0xc3, 0xb6, 0x1c, 0xe2, 0xd9, 0xa4, 0x61, 0xf9,
	0xb4, 0x71, 0xb6, 0xd3, 0x08, 0xed, 0x13, 0xe2, 0x44, 0x2e, 0xa9, 0xfb, 0x01, 0xe3, 0x0c, 0xdd,
	0x10, 0x9c, 0xba, 0xe2, 0xd4, 0x2d, 0x9f, 0xd6, 0xcf, 0x76, 0x36, 0xb6, 0x8e, 0x19, 0x3b, 0x76,
	0x49, 0x43, 0x52, 0x46, 0xd1, 0xb8, 0xe1, 0x44, 0x81, 0xc5, 0x29, 0xf3, 0x62, 0xd1, 0xc6, 0x9d,
	0x37, 0xe7, 0x39, 0x9d, 0x90, 0x90, 0x5b, 0x13, 0x5f, 0x11, 0xaa, 0x59, 0x2b, 0xdb, 0x6c, 0x32,
	0x49, 0x2d, 0x32, 0x63, 0xe3, 0x56, 0x78, 0xea, 0xd2, 0x90, 0xc7, 0x9c, 0xda, 0x6f, 0x1a, 0xac,
	0x1d, 0xaa, 0x70, 0x0f, 0x7d, 0x62, 0xa3, 0x07, 0x70, 0xdd, 0x0e, 0x98, 0x67, 0x92, 0x0b, 0x3f,
	0x20, 0x61, 0x48, 0x99, 0x57, 0xd1, 0xaa, 0xda, 0xc3, 0x02, 0x2e, 0x0b, 0xd8, 0x48, 0x51, 0xf4,
	0x05, 0x40, 0xc8, 0xad, 0x80, 0x9b, 0x22, 0xb0, 0x4a, 0xae, 0xaa, 0x3d, 0x2c, 0xee, 0x6e, 0xd4,
	0xe3, 0xa8, 0xeb, 0x49, 0xd4, 0xf5, 0x41, 0x12, 0x35, 0x2e, 0x48, 0xb6, 0x18, 0xa3, 0xcf, 0x60,
	0x95, 0x78, 0x4e, 0x2c, 0x5c, 0x5a, 0x28, 0xbc, 0x46, 0x3c, 0x47, 0xca, 0x76, 0x60, 0xe5, 0x7b,
	0xca, 0x39, 0x09, 0x2a, 0xcb, 0x52, 0xf4, 0xe1, 0x5b, 0xa2, 0x7d, 0x55, 0x43, 0xac, 0x88, 0xb5,
	0xbf, 0xf2, 0x50, 0x4e, 0xd2, 0x6b, 0xda, 0x62, 0x0a, 0x7d, 0x07, 0xe5, 0x38, 0xee, 0x73, 0x16,
	0x9c, 0x8e, 0x5d, 0x76, 0x2e, 0xf3, 0x2b, 0xee, 0x3e, 0xa9, 0x67, 0x6c, 0x53, 0xfd, 0x75, 0x71,
	0xfd, 0x50, 0x28, 0x8f, 0x94, 0x30, 0xc6, 0x70, 0x29, 0x9c, 0x05, 0x37, 0xfe, 0x59, 0x86, 0x1b,
	0x19, 0x34, 0x74, 0x00, 0xa5, 0x64, 0x45, 0x93, 0x4f, 0x7d, 0xa2, 0x96, 0xbd, 0x9b, 0xb9, 0x6c,
	0xa2, 0x1d, 0x4c, 0x7d, 0x82, 0xd7, 0xce, 0x67, 0x46, 0xe8, 0x4b, 0x28, 0x88, 0x3d, 0x34, 0xc5,
	0x26, 0xaa, 0xb2, 0x6f, 0x66, 0x7a, 0x0c, 0xac, 0xf0, 0xb4, 0x43, 0x43, 0x8e, 0x57, 0xb9, 0xfa,
	0x42, 0xbb, 0x90, 0xa7, 0x9e, 0x1f, 0x71, 0x55, 0xf5, 0xdb, 0x99, 0xba, 0xbe, 0x35, 0x75, 0x99,
	0xe5, 0xe0, 0x98, 0x8a, 0x3e, 0x01, 0x94, 0xc6, 0x4d, 0x1d, 0xd3, 0x0f, 0xc8, 0x98, 0x5e, 0xc8,
	0x1d, 0x28, 0x60, 0x3d, 0x99, 0x69, 0x3b, 0x7d, 0x89, 0x23, 0x0b, 0xaa, 0xe4, 0x82, 0xd8, 0x91,
	0x48, 0xd9, 0x54, 0xfd, 0xc1, 0x4c, 0xdb, 0x65, 0x21, 0x91, 0xfb, 0xcd, 0x22, 0x5e, 0xc9, 0x2f,
	0xda, 0xbd, 0xdb, 0xa9, 0x85, 0x2c, 0xe4, 0x80, 0xb5, 0x84, 0x7e, 0x10, 0xcb, 0xd1, 0x11, 0xdc,
	0x92, 0x05, 0x98, 0xe3, 0xbe, 0xb2, 0xc8, 0xfd, 0xa6, 0x50, 0x67, 0x19, 0xb7, 0x60, 0x2d, 0x20,
	0x3c, 0x98, 0x9a, 0x3e, 0x73, 0xa9, 0x3d, 0xad, 0x5c, 0x93, 0x4e, 0xd5, 0xcc, 0x22, 0x61, 0x41,
	0xec, 0x4b, 0x1e, 0x2e, 0x06, 0x97, 0x03, 0xf4, 0x18, 0x96, 0x27, 0x64, 0xc2, 0x2a, 0xab, 0x2a,
	0x8c, 0x2c, 0xf1, 0x0b, 0x32, 0x61, 0x58, 0xd2, 0x10, 0x86, 0xf5, 0x90, 0x58, 0x81, 0x7d, 0x62,
	0x5a, 0x9c, 0x07, 0x74, 0x14, 0x71, 0x12, 0x56, 0x0a, 0x52, 0x7b, 0x2f, 0xbb, 0x21, 0x25, 0xbb,
	0x99, 0x92, 0xb1, 0x1e, 0xbe, 0x81, 0xd4, 0xfe, 0xce, 0x81, 0x9e, 0xf4, 0xad, 0x8c, 0x8a, 0x92,
	0x10, 0x7d, 0x0d, 0x65, 0x76, 0x46, 0x02, 0xd7, 0xf2, 0x93, 0xf4, 0x44, 0xff, 0x95, 0x77, 0xb7,
	0xaf, 0x6c, 0xfb, 0x5e, 0x2c, 0x51, 0x89, 0x96, 0xd8, 0xec, 0x10, 0x61, 0xb8, 0x6e, 0x5b, 0xdc,
	0x3e, 0x31, 0xa3, 0xd4, 0x33, 0xf7, 0x0e, 0x9e, 0x2d, 0xa1, 0x19, 0xa6, 0x9e, 0xf6, 0xec, 0x10,
	0x35, 0x67, 0x3c, 0xcf, 0xa9, 0xe7, 0xb0, 0x73, 0xd5, 0xab, 0x57, 0x6c, 0x68, 0x62, 0x71, 0x24,
	0xf9, 0xe8, 0x21, 0xe8, 0xbe, 0x15, 0x85, 0xc4, 0x64, 0x9e, 0x39, 0xb6, 0xa8, 0x1b, 0x05, 0x44,
	0xb6, 0xeb, 0x2a, 0x2e, 0x4b, 0xbc, 0xe7, 0x1d, 0xc4, 0x28, 0xba, 0x0b, 0x6b, 0xa3, 0x68, 0x3c,
	0x26, 0x81, 0xe9, 0xd2, 0x09, 0x8d, 0x1b, 0x33, 0x8f, 0x8b, 0x31, 0xd6, 0x11, 0x10, 0x7a, 0x04,
	0xeb, 0x36, 0xf3, 0xec, 0x28, 0x08, 0x88, 0x67, 0x4f, 0x15, 0x6f, 0x45, 0xf2, 0xf4, 0x99, 0x09,
	0x49, 0xae, 0xfd, 0xa8, 0xc1, 0x7a, 0x5a, 0x78, 0xb1, 0x54, 0xdb, 0x1b, 0x33, 0xf4, 0x01, 0xac,
	0x04, 0xc4, 0x0a, 0xd3, 0x83, 0x54, 0x8d, 0xd0, 0x13, 0x28, 0xc8, 0x78, 0x1c, 0xd3, 0xe2, 0xef,
	0x70, 0x7e, 0xae, 0xc6, 0xe4, 0x26, 0x47, 0xb7, 0x52, 0xe1, 0x68, 0x2a, 0xab, 0x53, 0x48, 0x26,
	0xf7, 0xa6, 0x35, 0x0f, 0x4a, 0xe9, 0x79, 0xce, 0x2d, 0x4e, 0xc4, 0xf2, 0xf1, 0xa4, 0x5c, 0x7e,
	0x15, 0xab, 0x11, 0x32, 0x00, 0xe2, 0x32, 0x51, 0x6f, 0xcc, 0xd4, 0xfa, 0xf7, 0xaf, 0xdc, 0xb8,
	0x34, 0x25, 0x1c, 0xaf, 0x2f, 0x3e, 0x6b, 0x7f, 0x6a, 0xb0, 0xb6, 0x67, 0xd9, 0xa7, 0x63, 0xea,
	0xba, 0x32, 0xdd, 0x3b, 0x50, 0x1c, 0xa9, 0xb1, 0x49, 0x1d, 0x95, 0x33, 0x24, 0x50, 0xdb, 0xf9,
	0x1f, 0x2e, 0x8e, 0x7b, 0x50, 0x0e, 0x22, 0x2f, 0x34, 0x6d, 0x36, 0xf1, 0x5d, 0xc2, 0x89, 0x23,
	0xfb, 0x21, 0x8f, 0x4b, 0x02, 0x6d, 0x25, 0x20, 0xda, 0x04, 0x90, 0x34, 0xce, 0xb8, 0xe5, 0xaa,
	0x66, 0x28, 0x08, 0x64, 0x20, 0x80, 0xda, 0x0f, 0x4b, 0x97, 0x57, 0xa5, 0xcc, 0xf4, 0x19, 0x94,
	0x5c, 0x2b, 0xe4, 0x66, 0x10, 0x79, 0x71, 0x48, 0xda, 0xc2, 0x90, 0x8a, 0x42, 0x80, 0x23, 0x4f,
	0x86, 0xf5, 0x0c, 0x4a, 0x1e, 0xb9, 0x98, 0xd1, 0x2f, 0xae, 0x45, 0x51, 0x08, 0x12, 0xfd, 0x26,
	0x80, 0x0c, 0x55, 0x18, 0x84, 0xb2, 0x1e, 0x4b, 0xb8, 0x20, 0x11, 0x1c, 0x79, 0x21, 0x7a, 0x0a,
	0x45, 0x3b, 0x20, 0x16, 0x8f, 0x8f, 0x46, 0x75, 0x67, 0x5e, 0x65, 0x0e, 0x31, 0x5d, 0x7a, 0xef,
	0x83, 0x2e, 0x73, 0x8b, 0x7c, 0x27, 0x75, 0xc8, 0x2f, 0x74, 0x28, 0x0b, 0xcd, 0x50, 0x4a, 0xa4,
	0x4b, 0x17, 0xd6, 0x99, 0x77, 0xcc, 0xa8, 0x77, 0x6c, 0x26, 0x0d, 0x10, 0x56, 0x56, 0xaa, 0x4b,
	0x73, 0xef, 0xbd, 0xd9, 0x4e, 0xc2, 0xba, 0xd2, 0x26, 0x60, 0x58, 0xfb, 0x7d, 0xe6, 0x07, 0x13,
	0x17, 0x9a, 0xe1, 0xf1, 0x60, 0x2a, 0x3a, 0x2e, 0x79, 0x71, 0xcd, 0x74, 0x5c, 0x02, 0xb5, 0x9d,
	0xb7, 0xaf, 0xde, 0xdc, 0x7f, 0xbb, 0x7a, 0x3f, 0x87, 0x7c, 0x28, 0xfe, 0x29, 0xd5, 0x7b, 0xb5,
	0x2b, 0xff, 0x16, 0xf9, 0xf7, 0xe1, 0x58, 0x90, 0xf5, 0xaa, 0x5a, 0xce, 0x7a, 0x55, 0x6d, 0xff,
	0x94, 0x83, 0xf7, 0x33, 0x0f, 0x5f, 0xf4, 0x11, 0xdc, 0x39, 0x6c, 0x3d, 0x37, 0xf6, 0x87, 0x1d,
	0xc3, 0xec, 0xbd, 0x34, 0x70, 0xa7, 0xd9, 0x37, 0xfb, 0xbd, 0x4e, 0xbb, 0xf5, 0x8d, 0xd9, 0xee,
	0xbe, 0x6c, 0x76, 0xda, 0xfb, 0xfa, 0x7b, 0xe8, 0x63, 0xa8, 0xce, 0x23, 0x1d, 0x7e, 0xd5, 0xee,
	0x9b, 0x5d, 0xe3, 0x48, 0xd7, 0x50, 0x0d, 0xb6, 0xe6, 0xb1, 0xf6, 0x86, 0x07, 0x07, 0x06, 0xd6,
	0x73, 0xe8, 0x3e, 0xd4, 0xe6, 0x71, 0x5a, 0xbd, 0x6e, 0x6b, 0x88, 0xb1, 0xd1, 0x1d, 0xe8, 0x4b,
	0xe8, 0x11, 0x3c, 0x98, 0xcb, 0x6b, 0x76, 0x5b, 0x46, 0xc7, 0xec, 0x63, 0xe3, 0x65, 0xbb, 0x37,
	0x3c, 0xd4, 0x97, 0x51, 0x1d, 0xb6, 0xe7, 0x91, 0x07, 0x06, 0x7e, 0xd1, 0xee, 0x36, 0x07, 0xc6,
	0x25, 0x3f, 0xbf, 0xfd, 0xb3, 0x76, 0x59, 0x8d, 0xd7, 0xae, 0x8d, 0xd7, 0x12, 0x6d, 0x35, 0x07,
	0xad, 0xe7, 0xe6, 0x30, 0xa3, 0x1c, 0x77, 0x61, 0x73, 0x2e, 0x4b, 0xd4, 0x43, 0xd7, 0x50, 0x15,
	0x6e, 0xcf, 0xa5, 0xf4, 0xba, 0x86, 0x9e, 0xbb, 0x92, 0xd1, 0xec, 0x74, 0xf4, 0xa5, 0x3d, 0xfa,
	0xcb, 0xab, 0x2d, 0xed, 0xd7, 0x57, 0x5b, 0xda, 0x1f, 0xaf, 0xb6, 0x34, 0xb8, 0x69, 0xb3, 0x49,
	0x56, 0x67, 0xec, 0xa5, 0x07, 0x73, 0x5f, 0xfc, 0x39, 0x7d, 0xed, 0xdb, 0x9d, 0x63, 0xca, 0x4f,
	0xa2, 0x51, 0xdd, 0x66, 0x93, 0xc6, 0xec, 0x5b, 0xfd, 0x31, 0x75, 0xdc, 0xc6, 0x31, 0x8b, 0xdf,
	0xfe, 0xea, 0xe1, 0xfe, 0xd4, 0xf2, 0xe9, 0xd9, 0xce, 0x68, 0x45, 0x62, 0x9f, 0xfe, 0x1b, 0x00,
	0x00, 0xff, 0xff, 0xd1, 0x43, 0xc0, 0xf5, 0x78, 0x0c, 0x00, 0x00,
}

func (m *ScheduleSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduleSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduleSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Jitter != nil {
		{
			size, err := m.Jitter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.EndTime != nil {
		{
			size, err := m.EndTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.CronExpression) > 0 {
		i -= len(m.CronExpression)
		copy(dAtA[i:], m.CronExpression)
		i = encodeVarintSchedule(dAtA, i, uint64(len(m.CronExpression)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScheduleAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduleAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduleAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StartWorkflow != nil {
		{
			size, err := m.StartWorkflow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScheduleAction_StartWorkflowAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduleAction_StartWorkflowAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduleAction_StartWorkflowAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SearchAttributes != nil {
		{
			size, err := m.SearchAttributes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Memo != nil {
		{
			size, err := m.Memo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.RetryPolicy != nil {
		{
			size, err := m.RetryPolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.TaskStartToCloseTimeout != nil {
		{
			size, err := m.TaskStartToCloseTimeout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.ExecutionStartToCloseTimeout != nil {
		{
			size, err := m.ExecutionStartToCloseTimeout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.WorkflowIdPrefix) > 0 {
		i -= len(m.WorkflowIdPrefix)
		copy(dAtA[i:], m.WorkflowIdPrefix)
		i = encodeVarintSchedule(dAtA, i, uint64(len(m.WorkflowIdPrefix)))
		i--
		dAtA[i] = 0x22
	}
	if m.Input != nil {
		{
			size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TaskList != nil {
		{
			size, err := m.TaskList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.WorkflowType != nil {
		{
			size, err := m.WorkflowType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SchedulePolicies) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchedulePolicies) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchedulePolicies) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ConcurrencyLimit != 0 {
		i = encodeVarintSchedule(dAtA, i, uint64(m.ConcurrencyLimit))
		i--
		dAtA[i] = 0x30
	}
	if m.BufferLimit != 0 {
		i = encodeVarintSchedule(dAtA, i, uint64(m.BufferLimit))
		i--
		dAtA[i] = 0x28
	}
	if m.PauseOnFailure {
		i--
		if m.PauseOnFailure {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.CatchUpWindow != nil {
		{
			size, err := m.CatchUpWindow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.CatchUpPolicy != 0 {
		i = encodeVarintSchedule(dAtA, i, uint64(m.CatchUpPolicy))
		i--
		dAtA[i] = 0x10
	}
	if m.OverlapPolicy != 0 {
		i = encodeVarintSchedule(dAtA, i, uint64(m.OverlapPolicy))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SchedulePauseInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchedulePauseInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchedulePauseInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PausedBy) > 0 {
		i -= len(m.PausedBy)
		copy(dAtA[i:], m.PausedBy)
		i = encodeVarintSchedule(dAtA, i, uint64(len(m.PausedBy)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PausedAt != nil {
		{
			size, err := m.PausedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintSchedule(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScheduleState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduleState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduleState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PauseInfo != nil {
		{
			size, err := m.PauseInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Paused {
		i--
		if m.Paused {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BackfillInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackfillInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BackfillInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RunsTotal != 0 {
		i = encodeVarintSchedule(dAtA, i, uint64(m.RunsTotal))
		i--
		dAtA[i] = 0x28
	}
	if m.RunsCompleted != 0 {
		i = encodeVarintSchedule(dAtA, i, uint64(m.RunsCompleted))
		i--
		dAtA[i] = 0x20
	}
	if m.EndTime != nil {
		{
			size, err := m.EndTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.StartTime != nil {
		{
			size, err := m.StartTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.BackfillId) > 0 {
		i -= len(m.BackfillId)
		copy(dAtA[i:], m.BackfillId)
		i = encodeVarintSchedule(dAtA, i, uint64(len(m.BackfillId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScheduleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduleInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduleInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OngoingBackfills) > 0 {
		for iNdEx := len(m.OngoingBackfills) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OngoingBackfills[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchedule(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.LastUpdateTime != nil {
		{
			size, err := m.LastUpdateTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.CreateTime != nil {
		{
			size, err := m.CreateTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.TotalRuns != 0 {
		i = encodeVarintSchedule(dAtA, i, uint64(m.TotalRuns))
		i--
		dAtA[i] = 0x18
	}
	if m.NextRunTime != nil {
		{
			size, err := m.NextRunTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LastRunTime != nil {
		{
			size, err := m.LastRunTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScheduleListEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduleListEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScheduleListEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.CronExpression) > 0 {
		i -= len(m.CronExpression)
		copy(dAtA[i:], m.CronExpression)
		i = encodeVarintSchedule(dAtA, i, uint64(len(m.CronExpression)))
		i--
		dAtA[i] = 0x22
	}
	if m.State != nil {
		{
			size, err := m.State.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.WorkflowType != nil {
		{
			size, err := m.WorkflowType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchedule(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ScheduleId) > 0 {
		i -= len(m.ScheduleId)
		copy(dAtA[i:], m.ScheduleId)
		i = encodeVarintSchedule(dAtA, i, uint64(len(m.ScheduleId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintSchedule(dAtA []byte, offset int, v uint64) int {
	offset -= sovSchedule(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ScheduleSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CronExpression)
	if l > 0 {
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.EndTime != nil {
		l = m.EndTime.Size()
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.Jitter != nil {
		l = m.Jitter.Size()
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScheduleAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartWorkflow != nil {
		l = m.StartWorkflow.Size()
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScheduleAction_StartWorkflowAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WorkflowType != nil {
		l = m.WorkflowType.Size()
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.TaskList != nil {
		l = m.TaskList.Size()
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.Input != nil {
		l = m.Input.Size()
		n += 1 + l + sovSchedule(uint64(l))
	}
	l = len(m.WorkflowIdPrefix)
	if l > 0 {
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.ExecutionStartToCloseTimeout != nil {
		l = m.ExecutionStartToCloseTimeout.Size()
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.TaskStartToCloseTimeout != nil {
		l = m.TaskStartToCloseTimeout.Size()
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.RetryPolicy != nil {
		l = m.RetryPolicy.Size()
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.Memo != nil {
		l = m.Memo.Size()
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.SearchAttributes != nil {
		l = m.SearchAttributes.Size()
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SchedulePolicies) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OverlapPolicy != 0 {
		n += 1 + sovSchedule(uint64(m.OverlapPolicy))
	}
	if m.CatchUpPolicy != 0 {
		n += 1 + sovSchedule(uint64(m.CatchUpPolicy))
	}
	if m.CatchUpWindow != nil {
		l = m.CatchUpWindow.Size()
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.PauseOnFailure {
		n += 2
	}
	if m.BufferLimit != 0 {
		n += 1 + sovSchedule(uint64(m.BufferLimit))
	}
	if m.ConcurrencyLimit != 0 {
		n += 1 + sovSchedule(uint64(m.ConcurrencyLimit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SchedulePauseInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.PausedAt != nil {
		l = m.PausedAt.Size()
		n += 1 + l + sovSchedule(uint64(l))
	}
	l = len(m.PausedBy)
	if l > 0 {
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScheduleState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Paused {
		n += 2
	}
	if m.PauseInfo != nil {
		l = m.PauseInfo.Size()
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BackfillInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BackfillId)
	if l > 0 {
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.StartTime != nil {
		l = m.StartTime.Size()
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.EndTime != nil {
		l = m.EndTime.Size()
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.RunsCompleted != 0 {
		n += 1 + sovSchedule(uint64(m.RunsCompleted))
	}
	if m.RunsTotal != 0 {
		n += 1 + sovSchedule(uint64(m.RunsTotal))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScheduleInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastRunTime != nil {
		l = m.LastRunTime.Size()
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.NextRunTime != nil {
		l = m.NextRunTime.Size()
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.TotalRuns != 0 {
		n += 1 + sovSchedule(uint64(m.TotalRuns))
	}
	if m.CreateTime != nil {
		l = m.CreateTime.Size()
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.LastUpdateTime != nil {
		l = m.LastUpdateTime.Size()
		n += 1 + l + sovSchedule(uint64(l))
	}
	if len(m.OngoingBackfills) > 0 {
		for _, e := range m.OngoingBackfills {
			l = e.Size()
			n += 1 + l + sovSchedule(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScheduleListEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ScheduleId)
	if l > 0 {
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.WorkflowType != nil {
		l = m.WorkflowType.Size()
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.State != nil {
		l = m.State.Size()
		n += 1 + l + sovSchedule(uint64(l))
	}
	l = len(m.CronExpression)
	if l > 0 {
		n += 1 + l + sovSchedule(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovSchedule(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSchedule(x uint64) (n int) {
	return sovSchedule(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ScheduleSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduleSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduleSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CronExpression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CronExpression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &types.Timestamp{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = &types.Timestamp{}
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jitter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Jitter == nil {
				m.Jitter = &types.Duration{}
			}
			if err := m.Jitter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduleAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduleAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduleAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartWorkflow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartWorkflow == nil {
				m.StartWorkflow = &ScheduleAction_StartWorkflowAction{}
			}
			if err := m.StartWorkflow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduleAction_StartWorkflowAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartWorkflowAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartWorkflowAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorkflowType == nil {
				m.WorkflowType = &WorkflowType{}
			}
			if err := m.WorkflowType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TaskList == nil {
				m.TaskList = &TaskList{}
			}
			if err := m.TaskList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &Payload{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowIdPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkflowIdPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionStartToCloseTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExecutionStartToCloseTimeout == nil {
				m.ExecutionStartToCloseTimeout = &types.Duration{}
			}
			if err := m.ExecutionStartToCloseTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskStartToCloseTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TaskStartToCloseTimeout == nil {
				m.TaskStartToCloseTimeout = &types.Duration{}
			}
			if err := m.TaskStartToCloseTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryPolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RetryPolicy == nil {
				m.RetryPolicy = &RetryPolicy{}
			}
			if err := m.RetryPolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Memo == nil {
				m.Memo = &Memo{}
			}
			if err := m.Memo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SearchAttributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SearchAttributes == nil {
				m.SearchAttributes = &SearchAttributes{}
			}
			if err := m.SearchAttributes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchedulePolicies) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchedulePolicies: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchedulePolicies: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlapPolicy", wireType)
			}
			m.OverlapPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverlapPolicy |= ScheduleOverlapPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CatchUpPolicy", wireType)
			}
			m.CatchUpPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CatchUpPolicy |= ScheduleCatchUpPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CatchUpWindow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CatchUpWindow == nil {
				m.CatchUpWindow = &types.Duration{}
			}
			if err := m.CatchUpWindow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PauseOnFailure", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PauseOnFailure = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferLimit", wireType)
			}
			m.BufferLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BufferLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConcurrencyLimit", wireType)
			}
			m.ConcurrencyLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConcurrencyLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchedulePauseInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchedulePauseInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchedulePauseInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PausedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PausedAt == nil {
				m.PausedAt = &types.Timestamp{}
			}
			if err := m.PausedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PausedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PausedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduleState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduleState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduleState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paused = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PauseInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PauseInfo == nil {
				m.PauseInfo = &SchedulePauseInfo{}
			}
			if err := m.PauseInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackfillInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackfillInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackfillInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackfillId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BackfillId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = &types.Timestamp{}
			}
			if err := m.StartTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = &types.Timestamp{}
			}
			if err := m.EndTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunsCompleted", wireType)
			}
			m.RunsCompleted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RunsCompleted |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RunsTotal", wireType)
			}
			m.RunsTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RunsTotal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduleInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduleInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRunTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastRunTime == nil {
				m.LastRunTime = &types.Timestamp{}
			}
			if err := m.LastRunTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextRunTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NextRunTime == nil {
				m.NextRunTime = &types.Timestamp{}
			}
			if err := m.NextRunTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRuns", wireType)
			}
			m.TotalRuns = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRuns |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreateTime == nil {
				m.CreateTime = &types.Timestamp{}
			}
			if err := m.CreateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LastUpdateTime == nil {
				m.LastUpdateTime = &types.Timestamp{}
			}
			if err := m.LastUpdateTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OngoingBackfills", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OngoingBackfills = append(m.OngoingBackfills, &BackfillInfo{})
			if err := m.OngoingBackfills[len(m.OngoingBackfills)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduleListEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedule
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduleListEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduleListEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScheduleId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScheduleId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkflowType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WorkflowType == nil {
				m.WorkflowType = &WorkflowType{}
			}
			if err := m.WorkflowType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.State == nil {
				m.State = &ScheduleState{}
			}
			if err := m.State.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CronExpression", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedule
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchedule
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CronExpression = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchedule(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSchedule
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSchedule(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSchedule
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSchedule
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSchedule
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSchedule
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSchedule
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSchedule        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSchedule          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSchedule = fmt.Errorf("proto: unexpected end of group")
)
